'use server'

import { createHmac } from 'crypto'
import { headers } from 'next/headers'
import { eq, and } from 'drizzle-orm'
import type { GeneratePlaylistResponse } from '@crossfit-playlist/shared'
import { auth } from '@/lib/auth'
import { db } from '@/lib/db'
import { coachProfiles, savedPlaylists, trackFeedback, appSettings, userTasteProfile } from '@/lib/schema'

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000'
const API_SHARED_SECRET = process.env.API_SHARED_SECRET
const REQUEST_TIMEOUT_MS = 90000
const MAX_WORKOUT_TEXT_LENGTH = 5000

// ============================================================================
// Auth helpers
// ============================================================================

async function getSession() {
  return auth.api.getSession({ headers: await headers() })
}

async function requireSession() {
  const session = await getSession()
  if (!session) throw new Error('Authentication required')
  return session
}

// ============================================================================
// Spotify token
// ============================================================================

export async function getSpotifyAccessToken(): Promise<string | null> {
  try {
    const session = await getSession()
    if (!session) {
      console.warn('[spotify] No session — cannot fetch access token')
      return null
    }

    const result = await auth.api.getAccessToken({
      body: { providerId: 'spotify' },
      headers: await headers(),
    })

    if (!result?.accessToken) {
      console.warn('[spotify] getAccessToken returned no token', {
        userId: session.user.id,
        hasResult: !!result,
      })
      return null
    }

    return result.accessToken
  } catch (error) {
    console.error('[spotify] Failed to get access token:', error instanceof Error ? error.message : error)
    return null
  }
}

// ============================================================================
// Spotify export
// ============================================================================

export async function exportToSpotify(
  playlistName: string,
  trackUris: string[]
): Promise<{ spotifyUrl: string }> {
  await requireSession()

  const token = await getSpotifyAccessToken()
  if (!token) throw new Error('Spotify access token not available. Please sign in with Spotify.')
  if (trackUris.length === 0) throw new Error('No tracks to export')

  // 1. Get current user's Spotify ID
  const meRes = await fetch('https://api.spotify.com/v1/me', {
    headers: { Authorization: `Bearer ${token}` },
  })
  if (!meRes.ok) {
    const body = await meRes.text().catch(() => '')
    console.error('[spotify] /me failed:', { status: meRes.status, body })
    throw new Error('Failed to get Spotify user profile')
  }
  const me = await meRes.json()

  // 2. Create playlist
  console.info('[spotify] Creating playlist:', { name: playlistName, trackCount: trackUris.length, user: me.id })
  const createRes = await fetch(`https://api.spotify.com/v1/users/${me.id}/playlists`, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      name: playlistName,
      description: 'Generated by Crank — workout music, matched to your intensity',
      public: false,
    }),
  })
  if (!createRes.ok) {
    const body = await createRes.text().catch(() => '')
    console.error('[spotify] Create playlist failed:', { status: createRes.status, body })
    throw new Error('Failed to create Spotify playlist')
  }
  const playlist = await createRes.json()

  // 3. Add tracks (Spotify allows max 100 per request)
  for (let i = 0; i < trackUris.length; i += 100) {
    const batch = trackUris.slice(i, i + 100)
    const addRes = await fetch(`https://api.spotify.com/v1/playlists/${playlist.id}/tracks`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ uris: batch }),
    })
    if (!addRes.ok) {
      const body = await addRes.text().catch(() => '')
      console.error('[spotify] Add tracks failed:', { status: addRes.status, body, batch: i })
      throw new Error('Failed to add tracks to Spotify playlist')
    }
  }

  console.info('[spotify] Playlist exported:', { playlistId: playlist.id, url: playlist.external_urls.spotify })
  return { spotifyUrl: playlist.external_urls.spotify }
}

// ============================================================================
// Playlist generation
// ============================================================================

export async function generatePlaylist(
  workoutText: string,
  imageBase64?: string,
  imageMediaType?: string,
  genre?: string
): Promise<GeneratePlaylistResponse> {
  const hasText = workoutText?.trim()
  const hasImage = imageBase64 && imageMediaType

  if (!hasText && !hasImage) throw new Error('Either workout text or an image is required')
  if (hasText && workoutText.length > MAX_WORKOUT_TEXT_LENGTH)
    throw new Error(`Workout text is too long (max ${MAX_WORKOUT_TEXT_LENGTH} characters)`)

  const body: Record<string, string | undefined> = {}
  if (hasText) body.workout_text = workoutText
  if (hasImage) {
    body.workout_image_base64 = imageBase64
    body.image_media_type = imageMediaType
    if (hasText) body.workout_text = workoutText
  }

  // Build headers — pass user preferences to FastAPI if authenticated
  const fetchHeaders: Record<string, string> = { 'Content-Type': 'application/json' }

  const session = await getSession()
  if (session) {
    fetchHeaders['X-User-ID'] = session.user.id

    // Sign user ID with HMAC for backend verification
    if (API_SHARED_SECRET) {
      fetchHeaders['X-User-Signature'] = createHmac('sha256', API_SHARED_SECRET)
        .update(session.user.id)
        .digest('hex')
    }

    const profile = await db.query.coachProfiles.findFirst({
      where: eq(coachProfiles.userId, session.user.id),
    })

    if (profile) {
      if (genre) fetchHeaders['X-User-Genre'] = genre
      else if (profile.defaultGenre) fetchHeaders['X-User-Genre'] = profile.defaultGenre
      if (profile.excludeArtists && (profile.excludeArtists as string[]).length > 0) {
        fetchHeaders['X-User-Exclude-Artists'] = (profile.excludeArtists as string[]).join(',')
      }
      if (profile.minEnergy !== null && profile.minEnergy !== undefined) {
        fetchHeaders['X-User-Min-Energy'] = String(profile.minEnergy)
      }
    }

    // Pass track feedback to API for scoring adjustments
    const feedback = await getTrackFeedback()
    const boostedArtists: string[] = []
    const hiddenTracks: string[] = []
    for (const [trackId, rating] of Object.entries(feedback)) {
      if (rating === 1) {
        // Extract artist from trackId format "source:name:artist"
        const parts = trackId.split(':')
        if (parts.length >= 3) boostedArtists.push(parts[parts.length - 1])
      } else if (rating === -1) {
        hiddenTracks.push(trackId)
      }
    }
    if (boostedArtists.length > 0) {
      fetchHeaders['X-User-Boost-Artists'] = boostedArtists.join(',')
    }
    if (hiddenTracks.length > 0) {
      fetchHeaders['X-User-Hidden-Tracks'] = hiddenTracks.join(',')
    }

    // Merge taste profile data into boost/exclude lists
    const taste = await getTasteProfile()
    if (taste) {
      // Add liked artists from taste profile
      for (const artist of Object.keys(taste.likedArtists)) {
        if (!boostedArtists.includes(artist)) boostedArtists.push(artist)
      }
      // Add expanded (similar) artists
      for (const artist of taste.expandedArtists) {
        if (!boostedArtists.includes(artist)) boostedArtists.push(artist)
      }
      // Add onboarding picks
      for (const artist of taste.onboardingArtists) {
        if (!boostedArtists.includes(artist)) boostedArtists.push(artist)
      }
      // Update boost header with merged list
      if (boostedArtists.length > 0) {
        fetchHeaders['X-User-Boost-Artists'] = boostedArtists.join(',')
      }
      // Pass taste description as header
      if (taste.tasteDescription) {
        fetchHeaders['X-User-Taste-Description'] = taste.tasteDescription
      }
    }

    // Pass feature flags to backend
    const appSettings = await getAppSettings()
    if (appSettings.music_strategy) {
      fetchHeaders['X-Music-Strategy'] = appSettings.music_strategy
    }
  }

  // Pass genre for unauthenticated users too
  if (genre && !fetchHeaders['X-User-Genre']) {
    fetchHeaders['X-User-Genre'] = genre
  }

  const controller = new AbortController()
  const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT_MS)

  console.info('[generate] Starting request:', {
    apiUrl: API_URL,
    hasImage: !!hasImage,
    textLength: hasText ? workoutText.length : 0,
    genre: fetchHeaders['X-User-Genre'] || 'default',
    authenticated: !!session,
  })
  const startTime = Date.now()

  try {
    const response = await fetch(`${API_URL}/api/v1/generate`, {
      method: 'POST',
      headers: fetchHeaders,
      body: JSON.stringify(body),
      cache: 'no-store',
      signal: controller.signal,
    })

    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1)

    if (!response.ok) {
      const error = await response.json().catch(() => ({ detail: 'Unknown error' }))
      console.error('[generate] API error:', { status: response.status, detail: error.detail, elapsed: `${elapsed}s` })
      throw new Error(error.detail || `API error: ${response.status}`)
    }

    const result = await response.json()
    console.info('[generate] Success:', {
      elapsed: `${elapsed}s`,
      phases: result.workout?.phases?.length ?? 0,
      tracks: result.playlist?.tracks?.length ?? 0,
    })
    return result
  } catch (error) {
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1)
    if (error instanceof Error) {
      if (error.name === 'AbortError') {
        console.error('[generate] Request timed out after', `${elapsed}s`, `(limit: ${REQUEST_TIMEOUT_MS}ms)`)
        throw new Error('Request timed out. Please try again.')
      }
      console.error('[generate] Failed:', { message: error.message, elapsed: `${elapsed}s` })
      throw new Error(`Failed to generate playlist: ${error.message}`)
    }
    console.error('[generate] Unknown error after', `${elapsed}s`)
    throw new Error('Failed to generate playlist: Unknown error')
  } finally {
    clearTimeout(timeoutId)
  }
}

// ============================================================================
// Track feedback
// ============================================================================

export async function submitTrackFeedback(
  playlistId: string | null,
  trackId: string,
  rating: number
): Promise<void> {
  if (rating !== 1 && rating !== -1) throw new Error('Rating must be 1 or -1')

  const session = await requireSession()

  // Remove any existing feedback for this user+track
  await db
    .delete(trackFeedback)
    .where(
      and(
        eq(trackFeedback.userId, session.user.id),
        eq(trackFeedback.trackId, trackId)
      )
    )

  // Insert new feedback
  await db.insert(trackFeedback).values({
    userId: session.user.id,
    playlistId,
    trackId,
    rating,
  })

  // Update taste profile with aggregated artist feedback
  const { liked, disliked } = await aggregateArtistFeedback()
  await db
    .insert(userTasteProfile)
    .values({
      userId: session.user.id,
      likedArtists: liked,
      dislikedArtists: disliked,
      updatedAt: new Date(),
    })
    .onConflictDoUpdate({
      target: userTasteProfile.userId,
      set: {
        likedArtists: liked,
        dislikedArtists: disliked,
        updatedAt: new Date(),
      },
    })
}

export async function aggregateArtistFeedback(): Promise<{
  liked: Record<string, number>
  disliked: Record<string, number>
}> {
  const session = await getSession()
  if (!session) return { liked: {}, disliked: {} }

  const rows = await db.query.trackFeedback.findMany({
    where: eq(trackFeedback.userId, session.user.id),
  })

  const liked: Record<string, number> = {}
  const disliked: Record<string, number> = {}

  for (const row of rows) {
    // Extract artist from trackId format "source:name:artist"
    const parts = row.trackId.split(':')
    if (parts.length < 3) continue
    const artist = parts[parts.length - 1]

    if (row.rating === 1) {
      liked[artist] = (liked[artist] ?? 0) + 1
    } else if (row.rating === -1) {
      disliked[artist] = (disliked[artist] ?? 0) + 1
    }
  }

  return { liked, disliked }
}

export interface TrackFeedbackMap {
  [trackId: string]: number // 1 = thumbs up, -1 = thumbs down
}

export async function getTrackFeedback(
  playlistId?: string
): Promise<TrackFeedbackMap> {
  const session = await getSession()
  if (!session) return {}

  const rows = await db.query.trackFeedback.findMany({
    where: eq(trackFeedback.userId, session.user.id),
  })

  const map: TrackFeedbackMap = {}
  for (const row of rows) {
    map[row.trackId] = row.rating
  }
  return map
}

// ============================================================================
// Coach profile
// ============================================================================

export interface CoachProfileData {
  gymName?: string
  defaultGenre?: string
  preferredGenres?: string[]
  excludeArtists?: string[]
  minEnergy?: number
  allowExplicit?: boolean
}

export async function getProfile(): Promise<CoachProfileData | null> {
  const session = await getSession()
  if (!session) return null

  const profile = await db.query.coachProfiles.findFirst({
    where: eq(coachProfiles.userId, session.user.id),
  })

  if (!profile) return null

  return {
    gymName: profile.gymName ?? undefined,
    defaultGenre: profile.defaultGenre ?? 'rock',
    preferredGenres: (profile.preferredGenres as string[]) ?? [],
    excludeArtists: (profile.excludeArtists as string[]) ?? [],
    minEnergy: profile.minEnergy ?? 0.5,
    allowExplicit: profile.allowExplicit ?? false,
  }
}

export async function updateProfile(data: CoachProfileData): Promise<CoachProfileData> {
  const session = await requireSession()

  const now = new Date()
  await db
    .insert(coachProfiles)
    .values({
      userId: session.user.id,
      gymName: data.gymName ?? null,
      defaultGenre: data.defaultGenre ?? 'rock',
      preferredGenres: data.preferredGenres ?? [],
      excludeArtists: data.excludeArtists ?? [],
      minEnergy: data.minEnergy ?? 0.5,
      allowExplicit: data.allowExplicit ?? false,
      createdAt: now,
      updatedAt: now,
    })
    .onConflictDoUpdate({
      target: coachProfiles.userId,
      set: {
        gymName: data.gymName ?? null,
        defaultGenre: data.defaultGenre ?? 'rock',
        preferredGenres: data.preferredGenres ?? [],
        excludeArtists: data.excludeArtists ?? [],
        minEnergy: data.minEnergy ?? 0.5,
        allowExplicit: data.allowExplicit ?? false,
        updatedAt: now,
      },
    })

  return data
}

// ============================================================================
// Saved playlists
// ============================================================================

export interface SavePlaylistInput {
  name: string
  workoutText?: string
  workoutStructure: unknown
  playlistData: unknown
}

export async function savePlaylist(input: SavePlaylistInput): Promise<{ id: string }> {
  const session = await requireSession()

  const [inserted] = await db
    .insert(savedPlaylists)
    .values({
      userId: session.user.id,
      name: input.name,
      workoutText: input.workoutText ?? null,
      workoutStructure: input.workoutStructure,
      playlistData: input.playlistData,
    })
    .returning({ id: savedPlaylists.id })

  return { id: inserted.id }
}

export interface SavedPlaylistSummary {
  id: string
  name: string
  workoutText: string | null
  trackCount: number
  createdAt: string
}

export async function listPlaylists(): Promise<SavedPlaylistSummary[]> {
  const session = await requireSession()

  const rows = await db.query.savedPlaylists.findMany({
    where: eq(savedPlaylists.userId, session.user.id),
    orderBy: (t, { desc }) => [desc(t.createdAt)],
  })

  return rows.map((row) => {
    const data = row.playlistData as { tracks?: unknown[] } | null
    return {
      id: row.id,
      name: row.name,
      workoutText: row.workoutText,
      trackCount: data?.tracks?.length ?? 0,
      createdAt: row.createdAt.toISOString(),
    }
  })
}

export async function getPlaylistById(id: string) {
  const session = await requireSession()

  const row = await db.query.savedPlaylists.findFirst({
    where: eq(savedPlaylists.id, id),
  })

  if (!row || row.userId !== session.user.id) return null

  return {
    id: row.id,
    name: row.name,
    workoutText: row.workoutText,
    workoutStructure: row.workoutStructure,
    playlistData: row.playlistData,
    createdAt: row.createdAt.toISOString(),
  }
}

export async function deletePlaylist(id: string): Promise<void> {
  const session = await requireSession()

  const row = await db.query.savedPlaylists.findFirst({
    where: eq(savedPlaylists.id, id),
  })

  if (!row || row.userId !== session.user.id) {
    throw new Error('Playlist not found')
  }

  await db.delete(savedPlaylists).where(eq(savedPlaylists.id, id))
}

// ============================================================================
// App settings (feature flags)
// ============================================================================

export type AppSettingsMap = Record<string, string>

export async function getAppSettings(): Promise<AppSettingsMap> {
  const rows = await db.query.appSettings.findMany()
  const map: AppSettingsMap = {}
  for (const row of rows) {
    map[row.key] = row.value
  }
  return map
}

export async function updateAppSetting(key: string, value: string): Promise<void> {
  await requireSession()
  const now = new Date()
  await db
    .insert(appSettings)
    .values({ key, value, updatedAt: now })
    .onConflictDoUpdate({
      target: appSettings.key,
      set: { value, updatedAt: now },
    })
}

// ============================================================================
// User taste profile
// ============================================================================

export interface TasteProfileData {
  likedArtists: Record<string, number>
  dislikedArtists: Record<string, number>
  expandedArtists: string[]
  tasteDescription: string | null
  onboardingArtists: string[]
}

export async function getTasteProfile(): Promise<TasteProfileData | null> {
  const session = await getSession()
  if (!session) return null

  const profile = await db.query.userTasteProfile.findFirst({
    where: eq(userTasteProfile.userId, session.user.id),
  })

  if (!profile) return null

  return {
    likedArtists: (profile.likedArtists as Record<string, number>) ?? {},
    dislikedArtists: (profile.dislikedArtists as Record<string, number>) ?? {},
    expandedArtists: (profile.expandedArtists as string[]) ?? [],
    tasteDescription: profile.tasteDescription,
    onboardingArtists: (profile.onboardingArtists as string[]) ?? [],
  }
}

export async function saveTasteProfile(data: Partial<TasteProfileData>): Promise<void> {
  const session = await requireSession()
  const now = new Date()

  await db
    .insert(userTasteProfile)
    .values({
      userId: session.user.id,
      likedArtists: data.likedArtists ?? {},
      dislikedArtists: data.dislikedArtists ?? {},
      expandedArtists: data.expandedArtists ?? [],
      tasteDescription: data.tasteDescription ?? null,
      onboardingArtists: data.onboardingArtists ?? [],
      updatedAt: now,
    })
    .onConflictDoUpdate({
      target: userTasteProfile.userId,
      set: {
        ...(data.likedArtists !== undefined && { likedArtists: data.likedArtists }),
        ...(data.dislikedArtists !== undefined && { dislikedArtists: data.dislikedArtists }),
        ...(data.expandedArtists !== undefined && { expandedArtists: data.expandedArtists }),
        ...(data.tasteDescription !== undefined && { tasteDescription: data.tasteDescription }),
        ...(data.onboardingArtists !== undefined && { onboardingArtists: data.onboardingArtists }),
        updatedAt: now,
      },
    })
}
