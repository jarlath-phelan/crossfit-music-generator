'use server'

import { createHmac } from 'crypto'
import { headers } from 'next/headers'
import { eq, and } from 'drizzle-orm'
import type { GeneratePlaylistResponse } from '@crossfit-playlist/shared'
import { auth } from '@/lib/auth'
import { db } from '@/lib/db'
import { coachProfiles, savedPlaylists, trackFeedback } from '@/lib/schema'

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000'
const API_SHARED_SECRET = process.env.API_SHARED_SECRET
const REQUEST_TIMEOUT_MS = 30000
const MAX_WORKOUT_TEXT_LENGTH = 5000

// ============================================================================
// Auth helpers
// ============================================================================

async function getSession() {
  return auth.api.getSession({ headers: await headers() })
}

async function requireSession() {
  const session = await getSession()
  if (!session) throw new Error('Authentication required')
  return session
}

// ============================================================================
// Spotify token
// ============================================================================

export async function getSpotifyAccessToken(): Promise<string | null> {
  try {
    const session = await getSession()
    if (!session) return null

    const result = await auth.api.getAccessToken({
      body: { providerId: 'spotify' },
      headers: await headers(),
    })

    return result?.accessToken ?? null
  } catch {
    return null
  }
}

// ============================================================================
// Spotify export
// ============================================================================

export async function exportToSpotify(
  playlistName: string,
  trackUris: string[]
): Promise<{ spotifyUrl: string }> {
  await requireSession()

  const token = await getSpotifyAccessToken()
  if (!token) throw new Error('Spotify access token not available. Please sign in with Spotify.')
  if (trackUris.length === 0) throw new Error('No tracks to export')

  // 1. Get current user's Spotify ID
  const meRes = await fetch('https://api.spotify.com/v1/me', {
    headers: { Authorization: `Bearer ${token}` },
  })
  if (!meRes.ok) throw new Error('Failed to get Spotify user profile')
  const me = await meRes.json()

  // 2. Create playlist
  const createRes = await fetch(`https://api.spotify.com/v1/users/${me.id}/playlists`, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      name: playlistName,
      description: 'Generated by CrossFit Playlist Generator',
      public: false,
    }),
  })
  if (!createRes.ok) throw new Error('Failed to create Spotify playlist')
  const playlist = await createRes.json()

  // 3. Add tracks (Spotify allows max 100 per request)
  for (let i = 0; i < trackUris.length; i += 100) {
    const batch = trackUris.slice(i, i + 100)
    const addRes = await fetch(`https://api.spotify.com/v1/playlists/${playlist.id}/tracks`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ uris: batch }),
    })
    if (!addRes.ok) throw new Error('Failed to add tracks to Spotify playlist')
  }

  return { spotifyUrl: playlist.external_urls.spotify }
}

// ============================================================================
// Playlist generation
// ============================================================================

export async function generatePlaylist(
  workoutText: string,
  imageBase64?: string,
  imageMediaType?: string,
  genre?: string
): Promise<GeneratePlaylistResponse> {
  const hasText = workoutText?.trim()
  const hasImage = imageBase64 && imageMediaType

  if (!hasText && !hasImage) throw new Error('Either workout text or an image is required')
  if (hasText && workoutText.length > MAX_WORKOUT_TEXT_LENGTH)
    throw new Error(`Workout text is too long (max ${MAX_WORKOUT_TEXT_LENGTH} characters)`)

  const body: Record<string, string | undefined> = {}
  if (hasText) body.workout_text = workoutText
  if (hasImage) {
    body.workout_image_base64 = imageBase64
    body.image_media_type = imageMediaType
    if (hasText) body.workout_text = workoutText
  }

  // Build headers â€” pass user preferences to FastAPI if authenticated
  const fetchHeaders: Record<string, string> = { 'Content-Type': 'application/json' }

  const session = await getSession()
  if (session) {
    fetchHeaders['X-User-ID'] = session.user.id

    // Sign user ID with HMAC for backend verification
    if (API_SHARED_SECRET) {
      fetchHeaders['X-User-Signature'] = createHmac('sha256', API_SHARED_SECRET)
        .update(session.user.id)
        .digest('hex')
    }

    const profile = await db.query.coachProfiles.findFirst({
      where: eq(coachProfiles.userId, session.user.id),
    })

    if (profile) {
      if (genre) fetchHeaders['X-User-Genre'] = genre
      else if (profile.defaultGenre) fetchHeaders['X-User-Genre'] = profile.defaultGenre
      if (profile.excludeArtists && (profile.excludeArtists as string[]).length > 0) {
        fetchHeaders['X-User-Exclude-Artists'] = (profile.excludeArtists as string[]).join(',')
      }
      if (profile.minEnergy !== null && profile.minEnergy !== undefined) {
        fetchHeaders['X-User-Min-Energy'] = String(profile.minEnergy)
      }
    }

    // Pass track feedback to API for scoring adjustments
    const feedback = await getTrackFeedback()
    const boostedArtists: string[] = []
    const hiddenTracks: string[] = []
    for (const [trackId, rating] of Object.entries(feedback)) {
      if (rating === 1) {
        // Extract artist from trackId format "source:name:artist"
        const parts = trackId.split(':')
        if (parts.length >= 3) boostedArtists.push(parts[parts.length - 1])
      } else if (rating === -1) {
        hiddenTracks.push(trackId)
      }
    }
    if (boostedArtists.length > 0) {
      fetchHeaders['X-User-Boost-Artists'] = boostedArtists.join(',')
    }
    if (hiddenTracks.length > 0) {
      fetchHeaders['X-User-Hidden-Tracks'] = hiddenTracks.join(',')
    }
  }

  // Pass genre for unauthenticated users too
  if (genre && !fetchHeaders['X-User-Genre']) {
    fetchHeaders['X-User-Genre'] = genre
  }

  const controller = new AbortController()
  const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT_MS)

  try {
    const response = await fetch(`${API_URL}/api/v1/generate`, {
      method: 'POST',
      headers: fetchHeaders,
      body: JSON.stringify(body),
      cache: 'no-store',
      signal: controller.signal,
    })

    if (!response.ok) {
      const error = await response.json().catch(() => ({ detail: 'Unknown error' }))
      throw new Error(error.detail || `API error: ${response.status}`)
    }

    return await response.json()
  } catch (error) {
    if (error instanceof Error) {
      if (error.name === 'AbortError') throw new Error('Request timed out. Please try again.')
      throw new Error(`Failed to generate playlist: ${error.message}`)
    }
    throw new Error('Failed to generate playlist: Unknown error')
  } finally {
    clearTimeout(timeoutId)
  }
}

// ============================================================================
// Track feedback
// ============================================================================

export async function submitTrackFeedback(
  playlistId: string | null,
  trackId: string,
  rating: number
): Promise<void> {
  if (rating !== 1 && rating !== -1) throw new Error('Rating must be 1 or -1')

  const session = await requireSession()

  // Remove any existing feedback for this user+track
  await db
    .delete(trackFeedback)
    .where(
      and(
        eq(trackFeedback.userId, session.user.id),
        eq(trackFeedback.trackId, trackId)
      )
    )

  // Insert new feedback
  await db.insert(trackFeedback).values({
    userId: session.user.id,
    playlistId,
    trackId,
    rating,
  })
}

export interface TrackFeedbackMap {
  [trackId: string]: number // 1 = thumbs up, -1 = thumbs down
}

export async function getTrackFeedback(
  playlistId?: string
): Promise<TrackFeedbackMap> {
  const session = await getSession()
  if (!session) return {}

  const rows = await db.query.trackFeedback.findMany({
    where: eq(trackFeedback.userId, session.user.id),
  })

  const map: TrackFeedbackMap = {}
  for (const row of rows) {
    map[row.trackId] = row.rating
  }
  return map
}

// ============================================================================
// Coach profile
// ============================================================================

export interface CoachProfileData {
  gymName?: string
  defaultGenre?: string
  preferredGenres?: string[]
  excludeArtists?: string[]
  minEnergy?: number
  allowExplicit?: boolean
}

export async function getProfile(): Promise<CoachProfileData | null> {
  const session = await getSession()
  if (!session) return null

  const profile = await db.query.coachProfiles.findFirst({
    where: eq(coachProfiles.userId, session.user.id),
  })

  if (!profile) return null

  return {
    gymName: profile.gymName ?? undefined,
    defaultGenre: profile.defaultGenre ?? 'rock',
    preferredGenres: (profile.preferredGenres as string[]) ?? [],
    excludeArtists: (profile.excludeArtists as string[]) ?? [],
    minEnergy: profile.minEnergy ?? 0.5,
    allowExplicit: profile.allowExplicit ?? false,
  }
}

export async function updateProfile(data: CoachProfileData): Promise<CoachProfileData> {
  const session = await requireSession()

  const now = new Date()
  await db
    .insert(coachProfiles)
    .values({
      userId: session.user.id,
      gymName: data.gymName ?? null,
      defaultGenre: data.defaultGenre ?? 'rock',
      preferredGenres: data.preferredGenres ?? [],
      excludeArtists: data.excludeArtists ?? [],
      minEnergy: data.minEnergy ?? 0.5,
      allowExplicit: data.allowExplicit ?? false,
      createdAt: now,
      updatedAt: now,
    })
    .onConflictDoUpdate({
      target: coachProfiles.userId,
      set: {
        gymName: data.gymName ?? null,
        defaultGenre: data.defaultGenre ?? 'rock',
        preferredGenres: data.preferredGenres ?? [],
        excludeArtists: data.excludeArtists ?? [],
        minEnergy: data.minEnergy ?? 0.5,
        allowExplicit: data.allowExplicit ?? false,
        updatedAt: now,
      },
    })

  return data
}

// ============================================================================
// Saved playlists
// ============================================================================

export interface SavePlaylistInput {
  name: string
  workoutText?: string
  workoutStructure: unknown
  playlistData: unknown
}

export async function savePlaylist(input: SavePlaylistInput): Promise<{ id: string }> {
  const session = await requireSession()

  const [inserted] = await db
    .insert(savedPlaylists)
    .values({
      userId: session.user.id,
      name: input.name,
      workoutText: input.workoutText ?? null,
      workoutStructure: input.workoutStructure,
      playlistData: input.playlistData,
    })
    .returning({ id: savedPlaylists.id })

  return { id: inserted.id }
}

export interface SavedPlaylistSummary {
  id: string
  name: string
  workoutText: string | null
  trackCount: number
  createdAt: string
}

export async function listPlaylists(): Promise<SavedPlaylistSummary[]> {
  const session = await requireSession()

  const rows = await db.query.savedPlaylists.findMany({
    where: eq(savedPlaylists.userId, session.user.id),
    orderBy: (t, { desc }) => [desc(t.createdAt)],
  })

  return rows.map((row) => {
    const data = row.playlistData as { tracks?: unknown[] } | null
    return {
      id: row.id,
      name: row.name,
      workoutText: row.workoutText,
      trackCount: data?.tracks?.length ?? 0,
      createdAt: row.createdAt.toISOString(),
    }
  })
}

export async function getPlaylistById(id: string) {
  const session = await requireSession()

  const row = await db.query.savedPlaylists.findFirst({
    where: eq(savedPlaylists.id, id),
  })

  if (!row || row.userId !== session.user.id) return null

  return {
    id: row.id,
    name: row.name,
    workoutText: row.workoutText,
    workoutStructure: row.workoutStructure,
    playlistData: row.playlistData,
    createdAt: row.createdAt.toISOString(),
  }
}

export async function deletePlaylist(id: string): Promise<void> {
  const session = await requireSession()

  const row = await db.query.savedPlaylists.findFirst({
    where: eq(savedPlaylists.id, id),
  })

  if (!row || row.userId !== session.user.id) {
    throw new Error('Playlist not found')
  }

  await db.delete(savedPlaylists).where(eq(savedPlaylists.id, id))
}
